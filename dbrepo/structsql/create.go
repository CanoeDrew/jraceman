package structsql

import (
  "database/sql"
  "log"
  "reflect"
  "strings"
)

// Placeholder is ? for MySQL,$N for PostgreSQL,
// SQLite uses either of those, Oracle is :param1

// ColumnNames generates a list of column names
// based on the fields of the given struct. For each field in the struct:
//   * The field name is converted to lower case.
func ColumnNames(entity interface{}) []string {
  val := reflect.Indirect(reflect.ValueOf(entity))
  typ := val.Type()
  numFields := typ.NumField()
  columnNames := make([]string, numFields)
  for i := 0; i < numFields; i++ {
    field := typ.Field(i)
    columnNames[i] = strings.ToLower(field.Name)
  }
  return columnNames
}

// CreateTable creates a table with the given name and with columns
// based on the fields of the given entity by using the sql string
// generated by CreateTableSql.
func CreateTable(db *sql.DB, tableName string, entity interface{}) error {
  sql := CreateTableSql(tableName, entity)
  _, err := db.Exec(sql)
  return err
}

// CreateTableSql generates an SQL CREATE TABLE command using
// the fields of the given struct. For each field in the struct:
//   * The field name is converted to lower case for the column name.
//   * int and string fields are declared as that same type column.
//   * The id field is declared as primary key.
//   * Non-pointer fields are declared as not null.
//   * Field names ending in ID are declared as foreign key references to the
//     id field of a table whose name matches the first part of the field name
func CreateTableSql(tableName string, entity interface{}) string {
  val := reflect.Indirect(reflect.ValueOf(entity))
  typ := val.Type()
  numFields := typ.NumField()
  columnSpecs := make([]string, numFields)
  for i := 0; i < numFields; i++ {
    field := typ.Field(i)
    columnName := strings.ToLower(field.Name)
    goTypeName := field.Type.String()     // string, *string, int
    isPointer := strings.HasPrefix(goTypeName, "*")
    isForeignKey := strings.HasSuffix(field.Name, "ID")
    goTypeName = strings.TrimPrefix(goTypeName, "*")
    columnType := goTypeName            // TODO - convert as required
    columnSpec := columnName + " " + columnType
    if columnName == "id" {
      columnSpec = columnSpec + " primary key"
    } else {
      if !isPointer {
        columnSpec = columnSpec + " not null"
      }
      if isForeignKey {
        referenceTable := strings.TrimSuffix(columnName, "id")
        columnSpec = columnSpec + " references " + referenceTable + "(id)"
      }
    }
    columnSpecs[i] = columnSpec
  }
  sql := "CREATE TABLE " + tableName + "(" + strings.Join(columnSpecs, ", ") + ");"
  log.Printf("CreateTableSql: %v\n", sql)
  return sql
}

